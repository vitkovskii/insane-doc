package main

import (
	"fmt"
	"insane-doc/logger"
	"io/ioutil"
	"os"
	"strings"

	"github.com/alecthomas/kingpin"
)

const (
	termBlockStart  = `{!`
	termBlockEnd    = `!}`
	termInsertStart = `[!`
	termInsertEnd   = `!]`
	termItem        = `*!`
	termMultiline   = `>!`
)

var (
	file     = kingpin.Flag("file", "file").Short('f').String()
	template = kingpin.Flag("template", "template").Short('t').String()

	blockProcessors = map[string]processor{}

	blockInfos = map[string]blockInfo{}
)

type processor func(blockInfo blockInfo, command string) string

type blockInfo struct {
	name     string
	instance string
	params   []string
	lines    []string
}

func processOptions(blockInfo blockInfo, command string) string {
	switch command {
	case "variants":
		extractor := NewExtractor(blockInfo.params[0])
		variants := make([]string, 0, 0)
		iterateItems(blockInfo.lines, func(line string, text string, comment string) {
			variants = append(variants, extractor.extract(line))
		})

		return strings.Join(variants, "|")
	case "legend":
		legend := make([]string, 0, 0)
		iterateItems(blockInfo.lines, func(line string, text string, comment string) {
			extractor := NewExtractor(blockInfo.params[0])
			processed := ""
			substituteBlocks(comment, func(chunk string) {
				processed += chunk
			})
			name := extractor.extract(line)
			legend = append(legend, fmt.Sprintf("* `%s` â€“ %s", name, comment))
		})

		return strings.Join(legend, "\n")
	}

	logger.Fatalf("option block %s should use only variants or legend command, got=%s", blockInfo.instance, command)
	return ""
}

func processValues(blockInfo blockInfo, command string) string {
	nameExtractor := NewExtractor(blockInfo.params[0])
	valueExtractor := NewExtractor(blockInfo.params[1])
	result := ""
	iterateItems(blockInfo.lines, func(line string, text string, comment string) {
		name := nameExtractor.extract(line)
		if name != command {
			return
		}

		result = valueExtractor.extract(line)
	})

	if result == "" {
		logger.Fatalf("can't find value %s of value list block %s", command, blockInfo.instance)
	}

	return result
}

func processParams(blockInfo blockInfo, _ string) string {
	result := ""
	extractor := NewExtractor(blockInfo.params[0])

	iterateItems(blockInfo.lines, func(line string, text string, comment string) {
		processed := ""
		substituteBlocks(comment, func(chunk string) {
			processed += chunk
		})
		result += fmt.Sprintf("### %s \n %s\n", extractor.extract(line), processed)
	})
	result += "\n"
	return result
}

func processComment(blockInfo blockInfo, _ string) string {
	return strings.Join(blockInfo.lines, "\n")
}

func processVal(blockInfo blockInfo, _ string) string {
	if len(blockInfo.params) != 1 {
		logger.Fatal("val tag requires exactly one param, got=%s", blockInfo.params)
	}

	extractor := NewExtractor(blockInfo.params[0])

	if len(blockInfo.lines) == 0 {
		logger.Fatal("val tag requires at least one line")
	}

	return extractor.extract(blockInfo.lines[0])
}

func process(blockInstance string, command string) string {
	info, has := blockInfos[blockInstance]
	if !has {
		logger.Fatalf("can't find block name=%q", blockInstance)
	}

	proc, has := blockProcessors[info.name]
	if !has {
		logger.Fatalf("can't find proc for block name=%q", blockInstance)
	}
	return proc(info, command)
}

func iterateItems(lines []string, fn func(line string, text string, comment string)) {
	comment := ""
	for _, line := range lines {
		st := strings.Index(line, termItem)
		if st != -1 {
			if comment == "" {
				comment = line[st+len(termItem):]
			}
			fn(line, strings.TrimSpace(line[:st]), strings.TrimSpace(comment))
			comment = ""
			continue
		}

		st = strings.Index(line, termMultiline)
		if st != -1 {
			comment += strings.TrimSpace(line[st+len(termMultiline):]) + "\n"
		}
	}
}

func getFile(filename string) string {
	bytes, err := ioutil.ReadFile(filename)
	if err != nil {
		logger.Fatalf(err.Error())
	}

	return string(bytes)
}

func iterateTerms(content string, startTerm string, endTerm string, termFn func(sourceLine string, content string), otherFn func(content string)) {
	for len(content) != 0 {
		st := strings.Index(content, startTerm)
		if st == -1 {
			if otherFn != nil {
				otherFn(content)
			}

			return
		}

		end := strings.Index(content[st:], endTerm)
		if end == -1 {
			logger.Fatalf("can't find tag end")
		}

		if otherFn != nil {
			otherFn(content[:st])
		}

		termFn(line(content, st), strings.TrimSpace(content[st+len(termBlockStart):st+end]))
		content = content[st+end+len(endTerm):]
	}
}

func line(s string, index int) string {
	i := index
	for i > 0 {
		if s[i] == '\n' {
			i++
			break
		}
		i--
	}
	j := index
	for j < len(s) {
		if s[j] == '\n' {
			j--
			break
		}
		j++
	}

	return s[i:j]
}

func fillBlockInfo(line string, blockContent string) {
	lines := strings.Split(blockContent, "\n")
	if len(lines) <= 1 {
		lines = []string{blockContent, line}
	}
	firstLine := strings.TrimSpace(lines[0])

	params := strings.Split(firstLine, " ")
	if len(params) <= 1 {
		logger.Fatalf("why no params for block? %s", firstLine)
	}

	name := strings.TrimSpace(params[0])

	instanceExtractor := NewExtractor(strings.TrimSpace(params[1]))
	instance := instanceExtractor.extract(lines[1])

	_, has := blockProcessors[name]
	if !has {
		logger.Fatalf("no processor for block %s found", name)
	}

	logger.Infof("added block name=%s instance=%s", name, instance)
	blockInfos[instance] = blockInfo{
		name:     name,
		instance: instance,
		params:   params[2:],
		lines:    lines[1:],
	}
}

func substituteBlocks(content string, fn func(chunk string)) {
	iterateTerms(content, termInsertStart, termInsertEnd, func(line string, content string) {
		if content[0] != '@' {
			logger.Fatalf("wrong block name: %s", content)
		}
		parts := strings.Split(content[1:], ".")
		if len(parts) < 2 {
			parts = append(parts, "")
		}
		fn(process(strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])))
	}, func(tagContent string) {
		fn(tagContent)
	})

}

func _main() {
	kingpin.Parse()

	blockProcessors = map[string]processor{
		"val":     processVal,
		"params":  processParams,
		"comment": processComment,
		"values":  processValues,
		"options": processOptions,
	}

	iterateTerms(getFile(*file), termBlockStart, termBlockEnd, fillBlockInfo, nil)

	out := strings.Replace(*template, ".idoc", "", 1)
	f, err := os.OpenFile(out, os.O_APPEND|os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0777)
	if err != nil {
		logger.Fatalf("can't write output file %s: %s", out, err.Error())
	}

	substituteBlocks(getFile(*template), func(content string) {
		fmt.Print(content)
		_, err := f.WriteString(content)
		if err != nil {
			logger.Fatalf("can't write output file %s: %s", out, err.Error())
		}
	})
}
